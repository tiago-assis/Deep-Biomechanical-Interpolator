/*
 * ExplicitSim - Software for solving PDEs using explicit methods.
 * Copyright (C) 2017  <Konstantinos A. Mountris> <konstantinos.mountris@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contributors (alphabetically):
 *      George C. BOURANTAS
 *      Grand R. JOLDES
 *      Konstantinos A. MOUNTRIS
 */


#ifndef EXPLICITSIM_MESH_IO_ABAQUS_IO_TPP_
#define EXPLICITSIM_MESH_IO_ABAQUS_IO_TPP_

#include "ExplicitSim/mesh_io/abaqus_io.hpp"

namespace ExplicitSim {

template <class MESHTYPE, class ELEMTYPE>
void AbaqusIO::SaveMesh(const MESHTYPE &mesh, const std::string &mesh_filename)
{
    // Check if mesh filename is given.
    if (mesh_filename.empty()) {
        std::string error = "ERROR: No filename was given to save the mesh.";
        throw std::invalid_argument(error.c_str());
    }

    // Copy the mesh filename to process it if necessary.
    std::string out_filename = mesh_filename;

    // Check if given output filename is in abaqus format (.inp).
    if (out_filename.substr(out_filename.length() - 4) != ".inp") {
        // Add abaqus (.inp) extension.
        out_filename = out_filename + ".inp";
    }

    //Open mesh output file.
    std::ofstream out(out_filename.c_str(), std::ios::out);

    // Save header information.
    out << "*Heading\n";
    out << "** Job name: ExplicitSim-mesh-job Model name: Model-1\n";
    out << "** Generated by: ExplicitSim, echo=NO, model=NO, history=NO, contact=NO\n";
    out << "**\n";
    out << "** PARTS\n";
    out << "**\n";
    out << "*Part, name=Part-1\n";
    out << "*Node\n";

    // Multimap container of the nodes with the id of the boundary they belong.
    std::multimap<int, Node> mapped_nodes;

    // Map of the boundary indices and names.
    std::map<int, std::string> mesh_boundaries;

    // Save mesh nodes coordinates.
    for (auto &node : mesh.Nodes()) {

        // Output node with corrected id for storage offset.
        out << node.Id() + 1 << "," << node.Coordinates().X() << ","
            << node.Coordinates().Y() << "," << node.Coordinates().Z() << std::endl;

        // Populate the mapped nodes and boundaries containers.
        mapped_nodes.emplace(node.BoundaryId(), node);
        mesh_boundaries.emplace(node.BoundaryId(), node.BoundaryName());
    }

    // Multimap container of the elements with the id of the partition they belong.
    std::multimap<int, ELEMTYPE> mapped_elems;

    // Map of the partitions' indices and names.
    std::map<int, std::string> mesh_parts;

    // Save mesh elements type info.
    switch (mesh.MeshType()) {
    case ExplicitSim::MeshType::tetrahedral :
        out << "*Element, type=C3D4\n";
        break;
    default:
        break;
    }

    // Save mesh elements.
    for (auto &elem : mesh.Elements()) {

        // Print elements according to given mesh type.
        // Should correct id and connectivity for storage offset.
        switch (mesh.MeshType()) {
        case ExplicitSim::MeshType::tetrahedral :
            out << elem.Id()+1 << "," << elem.N1()+1 << "," << elem.N2()+1 << ","
                << elem.N3()+1 << "," << elem.N4()+1 << std::endl;
            break;
        default:
            std::string error = "ERROR: Mesh with unknown element type can not be saved.";
            throw std::invalid_argument(error.c_str());
            break;
        }

        // Populate the mapped elements and partitions containers.
        mapped_elems.emplace(elem.PartitionId(), elem);
        mesh_parts.emplace(elem.PartitionId(), elem.PartitionName());
    }

    // Save the element partitions of the mesh.
    for (auto &part : mesh_parts) {
        // Skip writing partitions if no more than one exist.
        if (mesh_parts.size() <= 1) { break; }

        // Save the header of the element set.
        out << "*Elset, elset=" + part.second << std::endl;

        int count = 0;
        for (auto &el : mapped_elems) {
            if (el.first == part.first) {
                // Correct for storage offset.
                out << el.second.Id()+1 << ",";
                count++;
                // Save 10 elements per row in the output file.
                if (count == 10) { out << el.second.Id()+1 << "\n"; count = 0;}
            }
        }
        // Go to the next line.
        out << "\n";
    }

    // Save the node boundaries of the mesh.
    for (auto &boundary : mesh_boundaries) {
        // Skip writing boundaries if no more than one exist.
        if (mesh_boundaries.size() <= 1) { break; }

        // Save the header of the element set.
        out << "*Nset, nset=" + boundary.second << std::endl;

        int count = 0;
        for (auto &node : mapped_nodes) {
            if (node.first == boundary.first) {
                // Correct for storage offset.
                out << node.second.Id()+1 << ",";
                count++;
                // Save 10 elements per row in the output file.
                if (count == 10) { out << node.second.Id()+1 << "\n"; count = 0;}
            }
        }
        // Go to the next line.
        out << "\n";
    }

    // Save the ending mesh header.

    out << "*End Part\n" << "**\n";
    out << "** ASSEMBLY\n" << "**\n" << "*Assembly, name=Assembly\n";
    out << "**\n" << "*Instance, name=Part-1-1, part=Part-1\n";
    out << "*End Instance\n" << "**\n" << "*End Assembly";

    // Print success message.
    std::cout << "Mesh saved successfully in: \"" + out_filename + "\"\n";

    // Close the output file.
    out.close();

}


}  // End of namespace ExplicitSim



#endif //EXPLICITSIM_MESH_IO_ABAQUS_IO_TPP_
